---
title: "My first Blog post"
description: "This post is related to the gatsbyjs"
date: "2018-09-20"
image: ""
slug: "test"
tags: ["hello", "world", "jason", "werner"]
---

import { BlogPost } from '../../components/templates/blog-post'

# One App, Every Platform (Part 1)

## Introduction

Since its launch in 2016, [Expo](https://expo.io/) has become a cornerstone of the React Native community. Before Expo, when React Native was in its early stages, it was extremely frustrating for a non-native developer to work with. Expo changed the game and now any React developer can make excellent mobile apps for iOS and Android. It's my preferred tool for app development.

As of [SDK v33](https://blog.expo.io/expo-sdk-v33-0-0-is-now-available-52d1c99dfe4c) Expo supports `react-native-web` (RNW) which we're using in this tutorial for creating iOS, Android and Web apps with only **ONE** client codebase. ðŸ˜±ðŸ˜±ðŸ˜±

## Getting Started

The first thing we need is `expo-cli`. If you don't have it already, install it globally. Once installed, create a new directory and initialize our client inside it.

```sh
npm install -g expo-cli
mkdir cutting-edge-tutorial
cd cutting-edge-tutorial
expo init client
```

Select "blank (Typescript)" then give your app a name and slug.

![Names and slugs](https://i.imgur.com/k0fj976.png)

Congratulations! You now have a single codebase that can be built into iOS, Android, and Web apps! Try running the project with `yarn start` and press `w` in the console once you see the QR code. You can also download the [Expo Client](https://expo.io/tools) to run it on your phone by scanning that QR code (when on the same network as the development server).

## Make it pretty

Now I know you want get your hands dirty hacking some code, but before writing even one line, we have to make sure all our future code stays pretty! And by "pretty" I mean it maintains a standard of cleanliness and readability. Lucky for us, there's a package that does all of this automatically called [Prettier](https://prettier.io/).

To get everything set up, run the following commands:

```sh
yarn add prettier --dev --exact
yarn add pretty-quick husky --dev
```

Next, add this to your `package.json`

```json
{
  "husky": {
    "hooks": {
      "pre-commit": "pretty-quick --staged"
    }
  }
}
```

And finally, create a new file called `.prettierrc` and paste the following inside it. You can put the file in the same directory as your client is in so it will be shared with your server (which we will be making in the next part of this series).

```json
{
  "printWidth": 100,
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5"
}
```

These are the options I like to use, but if this isn't the right style for you, have a look at the [prettier options doc](https://prettier.io/docs/en/options.html) to learn how you can customize it.

Although Prettier does do a lot, it's not a fix all solution. At the end of the commit, it's your responsibility as the dev and duty to those you work with to implement best practices for readable code. Experiment with new best practices when you can (or want to switch things up), so you find what works best for you and those you work with. This is very, very important because if others can't understand your code, future-you won't be able to either.

## Routing

After Prettier, the first thing I always add to my clients is the router. Every app needs one and it's one of the most vital parts of an app, so there's no point in postponing it.

With projects focusing on mobile, I usually use [`react-navigation`](https://reactnavigation.org/), which is great, but for this series we're going to use [`react-router`](https://github.com/ReactTraining/react-router) because I like the API more when developing for web. Both projects are excellent, so I recommend becoming comfortable with both so you can choose the right one for your next project.

First let's install the dependencies. Then I'll explain.

```sh
yarn add react-router-dom react-router-native
yarn add --dev @types/react-router-dom @types/react-router-native
```

Working with `react-router` in our RNW environment is a little tricky. We have two different routing packages with the same API. `react-router-dom` for web and `react-router-native` for mobile. We have to make sure that when a user is on the web app they get the web router and when on mobile they are using the mobile router. To accomplish this we use a little RNW trick. When you have two files with the same name but one is suffixed with `.web` that one will be used for web while the other is used on mobile. So first create a directory in your client `./src/components/Router` and add three files to it:

- `index.tsx`
- `Router.tsx`
- `Router.web.tsx`

Now we are going to export the classes we need from both `react-router-dom` and `react-router-native` while using the `.web` suffix to tell the packager which file to use when.

```ts
// Router.tsx

import {
  NativeRouter,
  Route as NativeRoute,
  Link as NativeLink,
  Switch as NativeSwitch,
  Redirect as NativeRedirect,
} from 'react-router-native'

export const Router = NativeRouter
export const Route = NativeRoute
export const Link = NativeLink
export const Switch = NativeSwitch
export const Redirect = NativeRedirect
```

```ts
// Router.web.tsx

import {
  BrowserRouter,
  Route as WebRoute,
  Link as WebLink,
  Switch as WebSwitch,
  Redirect as WebRedirect,
} from 'react-router-dom'

export const Router = BrowserRouter
export const Route = WebRoute
export const Link = WebLink
export const Switch = WebSwitch
export const Redirect = WebRedirect
```

Now that our packager knows which router to use, we can set up the routing component.

```ts
// index.tsx

import * as React from 'react'
import { Router, Route, Switch, Redirect, Link } from './Router'
import Home from '../../screens/Home'

const MainRouter = () => (
  <Router>
    <Route path="/" exact component={Home} />
  </Router>
)

export default MainRouter
export { Router, Route, Switch, Redirect, Link }
```

You may have noticed that we're importing a `Home` component that does not exist. We'll make that now. Create a new directory `./src/screens/Home` and add these two files:

- `index.tsx`
- `Home.tsx`

```ts
// index.tsx

export { default } from './Home'
```

```ts
// Home.tsx

import * as React from 'react'
import { View, Text, StyleSheet } from 'react-native'

const Home = () => (
  <View style={styles.container}>
    <Text>I am the Home screen!</Text>
  </View>
)

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
})

export default Home
```

This `index.tsx` file may seem a little unnecessary but it's useful when you want to put a component between the screen and router. For example a component that gets data from the server and passes the result to the screen. Even though we don't need it now it's good to plan for the future and keeps things consistent.

Finally let's hook up the router. Change the `App.tsx` file in the root of your client to this:

```ts
import React from 'react';
import Router from './src/components/Router'

const App = () => (
  <Router />
)

export default App
```

That's it! You can now run the project and see that our router and home page are all hooked up!

## Conclusion

Congratulations on scrolling down this far! I hope everything above made sense and you're ready for [Part 2](). This is my first time making a tutorial series, so if things didn't make sense, I over explained some things, didn't explain things enough, or you want to say something else entirely be sure to let me know in the comments so that next time (or this time with edits), you can can absorb as much information as possible.

In the next part I'm going to teach you how to set up your server and connect it to the client with [Apollo](https://www.apollographql.com/) and to your Mongo with [Typegoose](https://github.com/szokodiakos/typegoose) as well as easily setting up accounts with [accounts.js](https://github.com/accounts-js/accounts).
\
\
[Part 2: Building Your New Favorite Server]()\
[Back to into]()\

export default BlogPost